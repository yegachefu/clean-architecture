보통 우리가 사용하는 일반적인 3계층 계층형 아키텍쳐는 웹 → 도메인 → 영속성 계층 구조로 이루어져 있다.

- 웹 : 요청을 받아 도메인 혹은 비즈니스 계층으로 전달한다.
- 서비스 : 비즈니스 로직 수행하고 도메인의 현재 상태를 CRUD하기 위해 영속성을 호출한다.

## 계층형 아키텍쳐의 문제점

### 1. 데이터베이스 주도 설계를 유도한다.

웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 결과적으로 데이터베이스에 의존한다. 

우리는 상태가 아니라 행동 중심으로 모델링을 하고, 전통적인 계층형 아키텍쳐는 디비 구조를 먼저 생각한다. 의존성이 데이터베이스에 있기 때문이다. 가장 큰 원인은 ORM을 사용하기 때문이다.

엔티티를 보통 영속성 계층에 두게 되는데 결국 영속성 계층과 도메인 계층 사이에 강한 결합이 생겨서 서비스 계층에서 즉시/지연로딩, 트랜잭션 등의 영속성 관련 작업들을 해주어야한다.

### 2. 지름길을 택하기 쉬워진다.

상위 계층에 위치한 컴포넌트에 접근하지 못하기 때문에 하위로 내려버리게 되는 불상사를 저지를 수 있다. 처음만 어렵지 다음은 쉽게 그렇게 하려고 하는데 이를 ‘깨진 창문 이론’ 이라고 한다.

그러다 결국 유틸리티 등의 컴포넌트가 영속성 계층까지 내려가게 된다.

### 3. 테스트하기 어려워진다.

계층을 뛰어넘어 내려가기도 한다. 그렇게 되면 아래의 문제점이 발생한다.

1. 유스케이스가 확장되면 핵심 도메인 로직이 퍼져나가게 된다.
2. 테스트를 하려면 영속성 계층도 모킹해야 해서 단위 테스트의 복잡도가 올라간다.

### 4. 유스케이스를 숨긴다.

기능을 추가하거나 변경해야할 때 도메인 로직이 여러 계층에 흩어지기 때문에 찾기가 어려워진다.

그렇다면 고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 한다면 어떨까? UserService 와 RegisterUserService로 나누는 것 처럼.

### 5. 동시 작업이 어려워진다.

계층별로 맡아 개발하기는 어렵고, 서로 다른 유스케이스에 대한 작업을 하는 것도 병합 충돌을 잠재적으로 품는다.
