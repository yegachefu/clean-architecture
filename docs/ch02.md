## 단일 책임 원칙 (Single Responsibility Principle)

```
컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
```

‘하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야 한다.’로 알려져 있지만 실제 의도는 위와 같다. 변경 이유가 한 가지이기 때문에 한 가지 일만 하게 되는건 맞지만 중요한 것은 이유가 하나라는 것이다.

어떠한 컴포넌트가 여러 컴포넌트에 의존하는 경우에 의존하는 컴포넌트에 변경이 일어나는 경우 같이 바뀌어야 한다.

컴포넌트에 코드가 많아질 수록 변경할 이유가 더 많아져서 점점 더 바꾸기 어려워진다.

## 의존성 역전 원칙 (Dependency Inversion Principle)

```
코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다.
```

계층형 아키텍쳐에서 항상 아래 계층을 의존하기 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다. 그러나 도메인 코드가 가장 중요한 코드인데(서비스니까) 영속성 코드가 바뀐다고 해서 도메인 코드까지 바꿀 수는 없다.

```
영속성 코드 : 디비 트랜잭션, 캐시 플러시 등등
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f92a7c34-58f1-4d4b-8104-c6ab895b492e/Untitled.png)

영속성 코드가 도메인 코드를 의존하고, 도메인 코드를 변경할 이유의 개수를 줄이자.

1. 엔티티를 도메인 계층으로 올린다.
2. 도메인 계층에 리파지토리 인터페이스를 만든다.
3. 영속성 계층에서 리파지토리 인터페이스를 구현한다.

## 클린 아키텍쳐

1. 도메인 코드가 바깥(프레임워크, 데이터베이스, UI 기술 등)으로 향하는 어떤 의존성도 없어야 한다.
2. 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.

도메인 코드에서는 어떤 영속성 프레임워크, UI 프레임워크가 사용되는지 알 수 없기 때문에 자유롭게 모델링할 수 있다. 예를 들어 DDD(Domain Driven Design)을 가장 순수한 형태로 적용해볼 수 있다.

**단, 도메인 계층이 영속성이나 UI같은 외부 계층과 분리되어야 해서 엔티티에 대한 모델을 각 층에서 유지보수해서 서로 변환해야 한다.**

## 육각형 아키텍쳐(헥사고날 아키텍쳐. 포트와 어댑터 아키첵쳐)

![https://mesh.dev/static/5218ecc01e2106b794a5831fda5baca3/f3baa/03.png](https://mesh.dev/static/5218ecc01e2106b794a5831fda5baca3/f3baa/03.png) (참고 : [https://mesh.dev/20210910-dev-notes-007-hexagonal-architecture/](https://mesh.dev/20210910-dev-notes-007-hexagonal-architecture/))

어댑터들과 애플리케이션 코어와 통신이 가능하려면 코어가 각각의 포트를 제공해야한다. 주도하는 어댑터에게는 유스케이스 클래스들에 의해 구현되고, 주도되는 어댑터에게는 어댑터에 의해 구현되고 코어가 호출하게 된다.

이를 계층으로 구성할 수도 있는데, 바깥쪽부터 어댑터 → 포트와 유스케이스 → 도메인 엔티티 순이다.

## 클린 아키텍쳐는 무슨 도움을 줄까?

1. 결론은 바깥쪽 코드에 의존하지 않게 돼서 영속성과 UI 에 특화된 문제로부터 자유로워지고, 변경할 이유의 수를 적게 해서 유지보수성을 좋게 한다.
2. 도메인 코드는 비즈니스 문제에 맞춰 모델링할 수 있다.(원래라면 영속성 엔티티를 먼저 설계하고 이에 맞춤)