# 04. 유스케이스 구현하기

### TL;DR

- [ ] 

---

### 유스케이스 둘러보기
유스케이스의 일
1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다.

**1. 입력을 받는다**
- `입력 유효성 검증`과는 다르다. 입력 유효성 검증은 다른곳에서 처리한다.
**2. 비즈니스 규칙을 검증한다**
- 유스케이스는 **비즈니스 규칙**을 검증할 책임이 있다. 그리고 **도메인 엔티티와 이 책임을 공유한다.**
> 입력 유효성 검증 vs 비즈니스 규칙 검증의 차이점 확인하기.

**3. 모델 상태를 조작한다**
- 비즈니스 규칙을 충족하면 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다.
- 일반적으로 도메인 객체의 상태를 바꾸고, 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해 영속성 객체에 저장될 수 있게 한다.

**4. 출력을 반환한다**
- 아웃고잉 어댑터에서 온 출력값을, 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환하는 것이다.


### 1. 입력 유효성 검증
- 호출하는 어댑터가 유스케이스에 입력을 전달하기 전에 입력 유효성 검사를 하면, 유스케이스에서 필요로 하는것을 다 검증했다고 믿을 수 있을까?
- 유스케이스는 하나 이상의 어댑터에서 호출될 텐데, 유효성 검증을 각각 구현해야 할까?
- 입력 모델이 입력 유효성 검사 문제를 다루도록 작성해보자

### 생성자의 힘
- 컴파일러는 유효하지 않은 상태의 객체를 생성하는 것을 경고해주지 못한다.
- 생성자를 직접 사용한다면 휴먼 에러를 줄일 수 있고, IDE의 지원을 받아 해결할 수 ㅣㅇㅆ다..

### 유스케이스마다 다른 입력모델
- `계좌 등록하기`, `계좌 정보 업데이트하기` 두가지 유스케이스는 비슷하지만, 목적이 다르다.
- 불변 커맨드 객체의 필드에 대해 null을 유효한 상태로 받는것은 code-smelly 한 부분이다. 그리고 유효성 검증에도 오류가 있다.
- 유스케이스에 커스텀 검증 로직을 넣는건 어플리케이션을 오염시키는 행위이다.
- 유스케이스 전용 입력 모델들은 유스케이스를 훨씬 명확하게 만들고, 불필요한 부수효과를 발생시키지 않는다.

### 비즈니스 규칙 검증하기
- 비즈니스 검증은 유스케이스의 로직이다.
- 그런데 언제 비즈니스 규칙을 검증하고, 입력 유효성을 검증해야 할까?
- 실용적인 구분점은 `비즈니스 규칙을 검증 = 도메인 모델의 현재 상태 접근`, 입력 유효성은 선언적으로 구현할 수 있고, 굳이 도메인의 상태를 의존할 필요가 없다.
- 입력 유효성 검증은 `구문상(syntactical)` 유효성을 검증하는 것이라고 할 수 있다.
- 비즈니스 규칙은 `의미적(semantical)` 유효성 검증하는 일이라고 할 수 있다.
    -e.g. 출금 계좌는 초과 출금되서는 안된다 = 비즈니스규칙, 송금되는 금액은 0보다 커야한다 = 유효성
- 비즈니스 규칙은 의미적 해석인데, 검증은 어떻게 할까? => 비즈니스 규칙을 도메인 엔티티 안에 넣는다.
- 도메인 안에 비즈니스 규칙이 있다면, 위치를 정하는 것도 쉽고 추론도 쉽다.
- 도메인에서 비즈니스 규칙 검증이 여의치 않으면, 유스케이스 코드에서 도메인엔티티 사용전 검증을 해도 된다.

### 풍부한 도메인 모델 vs 빈약한 도메인 모델
- 풍부한 도메인 모델(rich domain model)
    - 어플리케이션 코어에 가능한 많은 도메인 로직이 구현된다.
    - 엔티티는 상태변경을 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용한다.
    - 많은 비즈니스 규칙이 엔티티에 위치하게 된다.
- 빈약한 도메인 모델(anemic domain model)
    - 일반적으로 getter/setter만 포함하고, 어떠한 도메인 로직도 가지고 있지 않다.
    - 도메인 로직이 유스케이스 클래스에 구현돼 있단즌 것이다.
    
### 유스케이스마다 다른 출력 모델
- 유스케이스가 할 일을 다하면, 호출자에게 필요한 최소한의 데이터만 전달한다.
- 유스케이스 간의 같은 출력모델을 공유하게 되면, 유스케이스도 강결합 된다. 공유모델은 점점 커지게 되고, 유스케이스의 결함을 만들 수 있다.
- 도메인 엔티티를 출력 모델로 사용하고 싶은 유혹도 견뎌야 한다.

### 읽기전용 유스케이스는 어떨까
- 읽기전용을 유스케이스라고 언급하는건 조금 그렇다.
- 프로젝트 맥락에서 유스케이스로 간주되지 않는다면, 쿼리로 구현할 수 있다.
- 쿼리에 대한 인커밍 전용 포트를 만들고 `query service`에 구현한다.
- 읽기전용 쿼리는 쓰기가능한 유스케이스와 명확히 다르다.